<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>vizk</title>
</head>

<style>
html, body { margin:0; padding:0; overflow:hidden }
svg { position:fixed; top:0; left:0; height:100%; width:100% }
</style>

<body>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script type="module">
        const width = window.innerWidth;
        const height = window.innerHeight;

        const zoomTransformExtentFactor = 1;
        const zoomScaleExtentFactor = 1;

        let nodeScaleFactor = 3;
        let linkScaleFactor = 1;

        let centerForceStrengthFactor = 1;
        let repulsionForceStrengthFactor = 1;
        let attractionForceStrengthFactor = 1;

        let nodeBorderColor = "red";
        let nodeBorderSize = 0.5;
        let linkThickness = 1;
        let linkOpacity = 1;
        let linkColor = "gray";

        let graph = {
            nodes: [
                {},
                {},
                {},
                {},
                {},
                {},
                {},
            ],
            links: [
                {source: 0, target: 1},
                {source: 0, target: 4},
                {source: 0, target: 4},
                {source: 2, target: 3},
                {source: 1, target: 2}
            ]
        };

        const svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

        const g = svg.append("g")

        // On every tick, update the positions of the nodes and links
        let tick = () => {
            nodeSelection
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
            linkSelection
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y)
        }

        let dragStart = (event) => {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        let handleDrag = (event) => {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        let dragEnd = (event) => {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }

        let handleZoom = (event) => {
            g.attr("transform", event.transform)
        }

        // Count the number of links that the nodes have; used for scaling up
        // nodes
        graph.links.forEach((link) => {
            if (!graph.nodes[link.source]["size"]) graph.nodes[link.source]["size"] = 0;
            if (!graph.nodes[link.target]["size"]) graph.nodes[link.target]["size"] = 0;
            graph.nodes[link.source]["size"]++;
            graph.nodes[link.target]["size"]++;
        });

        const nodeSelection = g
            .selectAll()
            .data(graph.nodes)
            .join("circle")
                .attr("stroke", nodeBorderColor)
                .attr("stroke-width", nodeBorderSize)
                .attr("r", (d) => {
                    return d.size ? d.size * nodeScaleFactor : nodeScaleFactor
                })
                .attr("fill", (d) => "black")

        const linkSelection = g
            .selectAll()
            .data(graph.links)
            .join("line")
                .attr("stroke-width", linkThickness)
                .attr("stroke-opacity", linkOpacity)
                .attr("stroke", linkColor)
                .lower()

        nodeSelection.call(d3.drag()
            .on("start", dragStart)
            .on("drag", handleDrag)
            .on("end", dragEnd));

        const simulation = d3.forceSimulation(graph.nodes)
            // Move the nodes to the center when the simulation starts
            .force("center", d3.forceCenter(width / 2, height / 2))
            // Attract linked nodes
            .force("links", d3.forceLink(graph.links)
                            .strength(attractionForceStrengthFactor))
            // Repulse all nodes from each other by some force
            .force("repulsion", d3.forceManyBody().strength(-repulsionForceStrengthFactor))
            // Repulse nodes if they collide
            .force("collide", d3.forceCollide().radius((d) => d.size * nodeScaleFactor + 2))
            .on("tick", tick);

        svg.call(d3.zoom()
            .translateExtent([[zoomTransformExtentFactor * (-width), zoomTransformExtentFactor * (-height)],
                            [2 * zoomTransformExtentFactor * width, 2 * zoomTransformExtentFactor * height]])
            .scaleExtent([zoomScaleExtentFactor * 0.5, zoomScaleExtentFactor * 10])
            .on("zoom", handleZoom)
            .filter(() => {
                return (event.button == 0 || event.button == 1)
            })
        );
    </script>
</body>

</html>
